[{"C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\index.js":"1","C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\App.js":"2","C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\reportWebVitals.js":"3","C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\Header.js":"4","C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\WalkForm.js":"5","C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\WalkList.js":"6","C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\CityForm.js":"7","C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\Response.js":"8","C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\ResponseRainy.js":"9","C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\ResponseNight.js":"10","C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\ChangeBackground.js":"11"},{"size":425,"mtime":1614278052312,"results":"12","hashOfConfig":"13"},{"size":6719,"mtime":1615305527554,"results":"14","hashOfConfig":"13"},{"size":375,"mtime":1614278052313,"results":"15","hashOfConfig":"13"},{"size":838,"mtime":1614278052138,"results":"16","hashOfConfig":"13"},{"size":1610,"mtime":1614278052140,"results":"17","hashOfConfig":"13"},{"size":982,"mtime":1614278052140,"results":"18","hashOfConfig":"13"},{"size":1045,"mtime":1615138865072,"results":"19","hashOfConfig":"13"},{"size":8256,"mtime":1615143236842,"results":"20","hashOfConfig":"13"},{"size":8206,"mtime":1615143240905,"results":"21","hashOfConfig":"13"},{"size":9048,"mtime":1615303663527,"results":"22","hashOfConfig":"13"},{"size":1122,"mtime":1615303686632,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"1lq06f6",{"filePath":"27","messages":"28","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"26"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"26"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"26"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48","usedDeprecatedRules":"26"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\index.js",[],["51","52"],"C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\App.js",["53","54","55"],"C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\reportWebVitals.js",[],"C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\Header.js",[],"C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\WalkForm.js",["56"],"import React, { useState } from \"react\";\r\n\r\n//Defines the use states for the walk form\r\nfunction WalkForm(props) {\r\n  const [date, setDate] = useState(\"\");\r\n  const [time, setTime] = useState(\"\");\r\n  const [title, setTitle] = useState(\"\");\r\n\r\n  //Function to change the date, time and title when the form field change\r\n  function handleChange(event) {\r\n    let { name, value } = event.target;\r\n\r\n    switch (name) {\r\n      case \"date\":\r\n        setDate(value);\r\n        break;\r\n      case \"time\":\r\n        setTime(value);\r\n        break;\r\n      case \"title\":\r\n        setTitle(value);\r\n        break;\r\n    }\r\n  }\r\n\r\n  //Function to add the title, date and time to the table on submit\r\n  function handleSubmit(event) {\r\n    event.preventDefault();\r\n    props.onSubmit(title, date, time);\r\n    setDate(\"\");\r\n    setTime(\"\");\r\n    setTitle(\"\");\r\n  }\r\n\r\n  return (\r\n    //Walk form\r\n    <div className=\"WalkForm\">\r\n      <h2 id=\"EnterWalk\"> Enter a walk</h2>\r\n      <form onSubmit={handleSubmit}>\r\n        <label>\r\n          Title&nbsp;\r\n          <input\r\n            id=\"title\"\r\n            type=\"textarea\"\r\n            name=\"title\"\r\n            value={title}\r\n            onChange={handleChange}\r\n          />\r\n        </label>\r\n\r\n        <label>\r\n          Date&nbsp;\r\n          <input type=\"date\" name=\"date\" value={date} onChange={handleChange} />\r\n        </label>\r\n\r\n        <label>\r\n          Time&nbsp;\r\n          <input type=\"time\" name=\"time\" value={time} onChange={handleChange} />\r\n        </label>\r\n\r\n        <button>Add walk</button>\r\n      </form>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default WalkForm;\r\n","C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\WalkList.js",[],"C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\CityForm.js",[],"C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\Response.js",["57","58","59"],"import React from \"react\";\r\n\r\nfunction Response(props) {\r\n  let w = props.forecast;\r\n\r\n  // *** INITIAL FETCH FOR AN ARRAY OF HOURS\r\n  let unfilteredHours = Object.entries(w.forecast.forecastday[0].hour); // first fetch of all hours\r\n\r\n  //**FINDS DAYLIGHT HOURS */\r\n  let sunsetHour =\r\n    Number(w.forecast.forecastday[0].astro.sunset.slice(0, 2)) + 12; // finds and converts sunset\r\n  let sunriseHour = Number(w.forecast.forecastday[0].astro.sunrise.slice(0, 2)); //finds and converts sunset hours\r\n\r\n  // **FINDS START TIME ***\r\n  let startTime = null;\r\n  let optimumTime = \"\"; // optimum time needs to be defined as early as here because of the base case\r\n  let timeOfAccess = Number(w.location.localtime.slice(11, -3)); //Time the person accessed the website\r\n  timeOfAccess < sunriseHour\r\n    ? (startTime = sunriseHour)\r\n    : (startTime = timeOfAccess); // if time of access if before sunrise, start time is sunrise hour.\r\n  if (timeOfAccess > sunsetHour) optimumTime = \"Tomorrow\"; // if time of access is after sunset, optimal time is tomorrow\r\n  let sunnyHours = []; //these are the sunny hours in a day\r\n  for (let i = 0; i < unfilteredHours.length; i++) {\r\n    if (i > startTime && i < sunsetHour) sunnyHours.push(unfilteredHours[i]);\r\n  }\r\n\r\n  console.log(\"sunny hours \" + sunnyHours);\r\n  console.log(\"sunny hours stringified \" + JSON.stringify(sunnyHours));\r\n  console.log(\"sunny hours ZERO \" + sunnyHours[0]);\r\n  console.log(\"sunny hours ZERO TYPE \" + typeof sunnyHours);\r\n\r\n  /***FINDS DRY HOURS***/\r\n  //pushes the sunny hours to either a dryHours or rainyDayHours array\r\n  let dryHours = []; //these are dry hours in a day\r\n  let rainyDayHours = []; //hours to use on a rainy day (all)\r\n  for (let i = 0; i < sunnyHours.length; i++) {\r\n    for (let j = 0; j < sunnyHours[i].length; j++) {\r\n      if (sunnyHours[i][j].will_it_rain === 0) {\r\n        dryHours.push(sunnyHours[i]);\r\n      }\r\n    }\r\n  }\r\n  // *** IF NO DRY HOURS, ALL HOURS ARE \"ELIGIBLE\" HOURS***//\r\n  if (dryHours.length === 0) rainyDayHours = sunnyHours;\r\n\r\n  //**** SORTS HOURS INTO TEMERATURE TYPE *** //\r\n  let comfortableTemp = [];\r\n  let coldTemp = [];\r\n  let rainyCold = [];\r\n  let rainyHot = [];\r\n  let rainyComfortable = [];\r\n  let veryHot = [];\r\n\r\n  if (rainyDayHours.length === 0) {\r\n    //if not going to rain all day\r\n    for (let i = 0; i < dryHours.length; i++) {\r\n      // loop through dry hours array to find right hour\r\n      for (let j = 0; j < dryHours[i].length; j++) {\r\n        if ((dryHours[i][j].temp_c > 10) & (dryHours[i][j].temp_c <= 20)) {\r\n          comfortableTemp.push(dryHours[i]); // if temp between 10 and 20, push to comfortable array\r\n        } else if (dryHours[i][j].temp_c < 10) {\r\n          coldTemp.push(dryHours[i]); // if temp less than 10, push to coldtemp array\r\n        } else if (dryHours[i][j].temp_c > 20) {\r\n          veryHot.push(dryHours[i]); // if temp more than 20, push to veryhot array\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    //if whole day is rainy\r\n    for (let i = 0; i < rainyDayHours.length; i++) {\r\n      for (let j = 0; j < rainyDayHours[i].length; j++) {\r\n        if (\r\n          (rainyDayHours[i][j].temp_c > 10) &\r\n          (rainyDayHours[i][j].temp_c <= 20)\r\n        ) {\r\n          rainyComfortable.push(rainyDayHours[i]); //push temps between 10 and 20 to rainycomfortable\r\n        } else if (rainyDayHours[i][j].temp_c <= 10) {\r\n          rainyCold.push(rainyDayHours[i]); // push temps <= 10 to rainycold\r\n        } else if (rainyDayHours[i][j].temp_c > 20) {\r\n          rainyHot.push(rainyDayHours[i]); // push temps > 20 to rainyhot\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /***SORT TEMP ARRAYS BY A CONDITION ***/\r\n\r\n  let sortTemps = (oldArray, value, direction) => {\r\n    let newArray = oldArray.sort(function(a, b) {\r\n      switch (value) {\r\n        case \"wind_mph\":\r\n          if (direction === \"low-high\") {\r\n            return a[1].wind_mph - b[1].wind_mph;\r\n          } else return b[1].wind_mph - a[1].wind_mph;\r\n        case \"temp_c\":\r\n          if (direction === \"low-high\") {\r\n            return a[1].temp_c - b[1].temp_c;\r\n          } else return b[1].temp_c - a[1].temp_c;\r\n        case \"humidity\":\r\n          if (direction === \"low-high\") {\r\n            return a[1].humidity - b[1].humidity;\r\n          } else return b[1].humidity - a[1].humidity;\r\n        case \"totalprecip_mm\":\r\n          if (direction === \"low-high\") {\r\n            return a[1].totalprecip_mm - b[1].totalprecip_mm;\r\n          } else return b[1].totalprecip_mm - a[1].totalprecip_mm;\r\n      }\r\n    });\r\n    return newArray;\r\n  };\r\n  // uses the above function to sort all the temperatures in each array.\r\n  let sortedComfortableTemp = sortTemps(\r\n    comfortableTemp,\r\n    \"humidity\",\r\n    \"low-high\"\r\n  );\r\n  let sortedVeryHot = sortTemps(veryHot, \"wind_mph\", \"high-low\");\r\n  let sortedCold = sortTemps(coldTemp, \"wind_mph\", \"low-high\");\r\n  let sortedRainyCold = sortTemps(rainyCold, \"totalprecip_mm\", \"low-high\");\r\n  let sortedRainyHot = sortTemps(rainyHot, \"temp_c\", \"low-high\");\r\n  let sortedRainyComfortable = sortTemps(\r\n    rainyComfortable,\r\n    \"totalprecip_mm\",\r\n    \"low-high\"\r\n  );\r\n\r\n  // ** FINDS OPTIMUM TIME ** //\r\n  let weatherConditionsAtTime = \"\"; // weather conditions at time of walk\r\n  let icon = \"\";\r\n  //temp\r\n  let temperatureAtTime = \"\";\r\n  //functino to find the optimum time\r\n  let findTime = arrayToCheck => {\r\n    if (Number(arrayToCheck[0][0]) > 12) {\r\n      optimumTime = Number(arrayToCheck[0][0] - 12) + \".00 p.m.\";\r\n    } else if (Number(arrayToCheck[0][0]) === 12) {\r\n      optimumTime = Number(arrayToCheck[0][0]) + \".00 p.m.\";\r\n    } else {\r\n      optimumTime = Number(arrayToCheck[0][0]) + \".00 a.m.\";\r\n    }\r\n    weatherConditionsAtTime =\r\n      \"Weather at this time:  \" +\r\n      arrayToCheck[0][1].condition.text.toLowerCase(); //sets weather conditions\r\n    icon = arrayToCheck[0][1].condition.icon; //sets icon\r\n\r\n    temperatureAtTime =\r\n      \"Estimated temperature:  \" + arrayToCheck[0][1].temp_c + \"ºC\"; //sets weather conditions\r\n  };\r\n\r\n  //uses above function to find the optimum time by going through arrays in the following order:\r\n  if (sortedComfortableTemp.length > 0) {\r\n    findTime(sortedComfortableTemp);\r\n  } else if (sortedCold.length > 0) {\r\n    findTime(sortedCold);\r\n  } else if (sortedVeryHot.length > 0) {\r\n    findTime(sortedVeryHot);\r\n  } else if (sortedRainyComfortable.length > 0) {\r\n    findTime(sortedRainyComfortable);\r\n  } else if (sortedRainyHot.length > 0) {\r\n    findTime(sortedRainyHot);\r\n  } else if (sortedRainyCold.length > 0) {\r\n    findTime(sortedRainyCold);\r\n  } else if (timeOfAccess < sunsetHour) {\r\n    optimumTime = \"Now\"; // if none of the arrays have values, and time of access is before sunset, then\r\n    //the time is in the last hour before sunset. So people will need to get out now.\r\n  } else if (timeOfAccess === sunsetHour) {\r\n    optimumTime = \"Tomorrow\"; // best time is tomorrow if access time is after sunset\r\n  }\r\n  // *** DEFINES A LATE MESSAGE *** //\r\n  let lateMessage = \"\";\r\n  if (optimumTime === \"Tomorrow\") lateMessage += \"It's already dark.\";\r\n  if (optimumTime === \"Now\")\r\n    lateMessage += \"Get out quickly. It'll be dark within the hour.\";\r\n  if (optimumTime !== \"Tomorrow\" || optimumTime === \"Now\") {\r\n    return (\r\n      // This is the final response if a time is shown\r\n      <div className=\"Response\">\r\n        <p>\r\n          <h1 id=\"location\">\r\n            {w.location.name}, {w.location.country}\r\n          </h1>\r\n          The best time for your walk is<br></br>\r\n          <span id=\"time\">{optimumTime} </span>\r\n        </p>\r\n        <p>\r\n          <img id=\"icon\" src={icon} />\r\n          <br></br>\r\n          {weatherConditionsAtTime}\r\n          <br></br>\r\n          {temperatureAtTime}\r\n        </p>\r\n      </div>\r\n    );\r\n  } else {\r\n    return (\r\n      // This is the final response if \"tomorrow\" is shown\r\n      <div className=\"Response\">\r\n        <p>\r\n          <h1 id=\"location\">\r\n            {w.location.name}, {w.location.country}{\" \"}\r\n          </h1>{\" \"}\r\n          The best time for your walk is<br></br>\r\n          <span id=\"time\">{optimumTime} </span>\r\n          <br></br> {lateMessage}\r\n        </p>\r\n        <p></p>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Response;\r\n","C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\ResponseRainy.js",["60","61","62"],"import React from \"react\";\r\n\r\nfunction ResponseRainy(props) {\r\n  //On the rainy mood we maintain the light hours conditions.\r\n\r\n  let w = props.forecast;\r\n\r\n  // *** INITIAL FETCH FOR AN ARRAY OF HOURS\r\n  let unfilteredHours = Object.entries(w.forecast.forecastday[0].hour); // first fetch of all hours\r\n\r\n  //**FINDS DAYLIGHT HOURS */\r\n  let sunsetHour =\r\n    Number(w.forecast.forecastday[0].astro.sunset.slice(0, 2)) + 12; // finds and converts sunset\r\n  let sunriseHour = Number(w.forecast.forecastday[0].astro.sunrise.slice(0, 2)); //finds and converts sunset hours\r\n\r\n  // **FINDS START TIME ***\r\n  let startTime = null;\r\n  let optimumTime = \"\"; // optimum time needs to be defined as early as here because of the base case\r\n  let timeOfAccess = Number(w.location.localtime.slice(11, -3)); //Time the person accessed the website\r\n  timeOfAccess < sunriseHour\r\n    ? (startTime = sunriseHour)\r\n    : (startTime = timeOfAccess); // if time of access if before sunrise, start time is sunrise hour.\r\n  if (timeOfAccess > sunsetHour) optimumTime = \"Tomorrow\"; // if time of access is after sunset, optimal time is tomorrow\r\n  let dayLightHours = []; //these are the daylight hours in a day\r\n  for (let i = 0; i < unfilteredHours.length; i++) {\r\n    if (i > startTime && i < sunsetHour) dayLightHours.push(unfilteredHours[i]);\r\n  }\r\n\r\n  /***FINDS RAINY HOURS***/\r\n  //pushes the sunny hours to either a dryHours or rainyHours array\r\n  let dryHours = []; //these are dry hours in a day\r\n  let rainyHours = []; //hours to use on a rainy day (all)\r\n  for (let i = 0; i < dayLightHours.length; i++) {\r\n    for (let j = 0; j < dayLightHours[i].length; j++) {\r\n      //changing from ===0 (dry), to ===1 (rainy)\r\n      if (dayLightHours[i][j].will_it_rain === 1) {\r\n        rainyHours.push(dayLightHours[i]);\r\n      }\r\n    }\r\n  }\r\n  // *** IF NO RAINY HOURS, ALL HOURS ARE \"ELIGIBLE\" HOURS***//\r\n  if (rainyHours.length === 0) dryHours = dayLightHours;\r\n\r\n  //**** SORTS HOURS INTO TEMERATURE TYPE *** //\r\n  let comfortableTemp = [];\r\n  let coldTemp = [];\r\n  let rainyCold = [];\r\n  let rainyHot = [];\r\n  let rainyComfortable = [];\r\n  let veryHot = [];\r\n\r\n  if (rainyHours.length === 0) {\r\n    //if not going to rain all day\r\n    for (let i = 0; i < dryHours.length; i++) {\r\n      // loop through dry hours array to find right hour\r\n      for (let j = 0; j < dryHours[i].length; j++) {\r\n        if ((dryHours[i][j].temp_c > 10) & (dryHours[i][j].temp_c <= 20)) {\r\n          comfortableTemp.push(dryHours[i]); // if temp between 10 and 20, push to comfortable array\r\n        } else if (dryHours[i][j].temp_c < 10) {\r\n          coldTemp.push(dryHours[i]); // if temp less than 10, push to coldtemp array\r\n        } else if (dryHours[i][j].temp_c > 20) {\r\n          veryHot.push(dryHours[i]); // if temp more than 20, push to veryhot array\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    //if whole day is rainy\r\n    for (let i = 0; i < rainyHours.length; i++) {\r\n      for (let j = 0; j < rainyHours[i].length; j++) {\r\n        if (\r\n          //+5º to temp. as we don't have sunlight\r\n          (rainyHours[i][j].temp_c > 15) &\r\n          (rainyHours[i][j].temp_c <= 25)\r\n        ) {\r\n          rainyComfortable.push(rainyHours[i]); //push temps between 15 and 25 to rainycomfortable\r\n        } else if (rainyHours[i][j].temp_c <= 15) {\r\n          rainyCold.push(rainyHours[i]); // push temps <= 15 to rainycold\r\n        } else if (rainyHours[i][j].temp_c > 25) {\r\n          rainyHot.push(rainyHours[i]); // push temps > 25 to rainyhot\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /***SORT TEMP ARRAYS BY A CONDITION ***/\r\n\r\n  let sortTemps = (oldArray, value, direction) => {\r\n    let newArray = oldArray.sort(function(a, b) {\r\n      switch (value) {\r\n        case \"wind_mph\":\r\n          if (direction === \"low-high\") {\r\n            return a[1].wind_mph - b[1].wind_mph;\r\n          } else return b[1].wind_mph - a[1].wind_mph;\r\n        case \"temp_c\":\r\n          if (direction === \"low-high\") {\r\n            return a[1].temp_c - b[1].temp_c;\r\n          } else return b[1].temp_c - a[1].temp_c;\r\n        case \"humidity\":\r\n          if (direction === \"low-high\") {\r\n            return a[1].humidity - b[1].humidity;\r\n          } else return b[1].humidity - a[1].humidity;\r\n        case \"totalprecip_mm\":\r\n          if (direction === \"low-high\") {\r\n            return a[1].totalprecip_mm - b[1].totalprecip_mm;\r\n          } else return b[1].totalprecip_mm - a[1].totalprecip_mm;\r\n      }\r\n    });\r\n    return newArray;\r\n  };\r\n\r\n  // uses the above function to sort all the temperatures in each array.\r\n  let sortedComfortableTemp = sortTemps(\r\n    comfortableTemp,\r\n    \"humidity\",\r\n    \"low-high\"\r\n  );\r\n  let sortedVeryHot = sortTemps(veryHot, \"wind_mph\", \"high-low\");\r\n  let sortedCold = sortTemps(coldTemp, \"wind_mph\", \"low-high\");\r\n  let sortedRainyCold = sortTemps(rainyCold, \"totalprecip_mm\", \"low-high\");\r\n  let sortedRainyHot = sortTemps(rainyHot, \"temp_c\", \"low-high\");\r\n  let sortedRainyComfortable = sortTemps(\r\n    rainyComfortable,\r\n    \"totalprecip_mm\",\r\n    \"low-high\"\r\n  );\r\n\r\n  // ** FINDS OPTIMUM TIME ** //\r\n  let weatherConditionsAtTime = \"\"; // weather conditions at time of walk\r\n  let icon = \"\";\r\n  //temp\r\n  let temperatureAtTime = \"\";\r\n\r\n  //function to find the optimum time\r\n  let findTime = arrayToCheck => {\r\n    if (Number(arrayToCheck[0][0]) > 12) {\r\n      optimumTime = Number(arrayToCheck[0][0] - 12) + \".00 p.m.\";\r\n    } else if (Number(arrayToCheck[0][0]) === 12) {\r\n      optimumTime = Number(arrayToCheck[0][0]) + \".00 p.m.\";\r\n    } else {\r\n      optimumTime = Number(arrayToCheck[0][0]) + \".00 a.m.\";\r\n    }\r\n    weatherConditionsAtTime =\r\n      \"Weather at this time:  \" +\r\n      arrayToCheck[0][1].condition.text.toLowerCase(); //sets weather conditions\r\n    icon = arrayToCheck[0][1].condition.icon; //sets icon\r\n\r\n    temperatureAtTime =\r\n      \"Estimated temperature:  \" + arrayToCheck[0][1].temp_c + \"ºC\"; //sets weather conditions\r\n  };\r\n\r\n  //uses above function to find the optimum time by going through arrays in the following order:\r\n  if (sortedRainyComfortable.length > 0) {\r\n    findTime(sortedRainyComfortable);\r\n  } else if (sortedRainyHot.length > 0) {\r\n    findTime(sortedRainyHot);\r\n  } else if (sortedRainyCold.length > 0) {\r\n    findTime(sortedRainyCold);\r\n  } else if (sortedComfortableTemp.length > 0) {\r\n    findTime(sortedComfortableTemp);\r\n  } else if (sortedCold.length > 0) {\r\n    findTime(sortedCold);\r\n  } else if (sortedVeryHot.length > 0) {\r\n    findTime(sortedVeryHot);\r\n  } else if (timeOfAccess < sunsetHour) {\r\n    optimumTime = \"Now\"; // if none of the arrays have values, and time of access is before sunset, then\r\n    //the time is in the last hour before sunset. So people will need to get out now.\r\n  } else if (timeOfAccess === sunsetHour) {\r\n    optimumTime = \"Tomorrow\"; // best time is tomorrow if access time is after sunset\r\n  }\r\n  // *** DEFINES A LATE MESSAGE *** //\r\n  let lateMessage = \"\";\r\n  if (optimumTime === \"Tomorrow\") lateMessage += \"It's already dark.\";\r\n  if (optimumTime === \"Now\")\r\n    lateMessage += \"Get out quickly. It'll be dark within the hour.\";\r\n  if (optimumTime !== \"Tomorrow\" || optimumTime === \"Now\") {\r\n    return (\r\n      // This is the final response if a time is shown\r\n      <div className=\"ResponseRainy\">\r\n        <p>\r\n          <h1 id=\"location\">\r\n            {w.location.name}, {w.location.country}\r\n          </h1>\r\n          The best time for your rainy walk is<br></br>\r\n          <span id=\"time\">{optimumTime} </span>\r\n        </p>\r\n        <p>\r\n          <img id=\"icon\" src={icon} /> <br></br>\r\n          {weatherConditionsAtTime}\r\n          <br></br>\r\n          {temperatureAtTime}\r\n        </p>\r\n      </div>\r\n    );\r\n  } else {\r\n    return (\r\n      // This is the final response if \"tomorrow\" is shown\r\n      <div className=\"ResponseRainy\">\r\n        <p>\r\n          <h1 id=\"location\">\r\n            {w.location.name}, {w.location.country}{\" \"}\r\n          </h1>{\" \"}\r\n          The best time for your rainy walk is<br></br>\r\n          <span id=\"time\">{optimumTime} </span>\r\n          <br></br> {lateMessage}\r\n        </p>\r\n        <p></p>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ResponseRainy;\r\n","C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\ResponseNight.js",["63","64","65","66"],"import React from \"react\";\r\n\r\nfunction ResponseNight(props) {\r\n  let w = props.forecast;\r\n\r\n  // *** INITIAL FETCH FOR AN ARRAY OF HOURS\r\n  let unfilteredHoursDay1 = Object.entries(w.forecast.forecastday[0].hour);\r\n  // console.log(unfilteredHoursDay1);\r\n  let unfilteredHoursDay2 = Object.entries(w.forecast.forecastday[1].hour);\r\n\r\n  //**FINDS NIGHT HOURS DAY 1*/\r\n  let sunsetHourDay1 =\r\n    Number(w.forecast.forecastday[0].astro.sunset.slice(0, 2)) + 12; // finds and converts sunset\r\n  let sunriseHourDay1 = Number(\r\n    w.forecast.forecastday[0].astro.sunrise.slice(0, 2)\r\n  ); //finds and converts sunrise hours\r\n\r\n  //**FINDS NIGHT HOURS DAY 1*/\r\n  let sunsetHourDay2 =\r\n    Number(w.forecast.forecastday[1].astro.sunset.slice(0, 2)) + 12; // finds and converts sunset\r\n  let sunriseHourDay2 = Number(\r\n    w.forecast.forecastday[1].astro.sunrise.slice(0, 2)\r\n  ); //finds and converts sunrise hours\r\n\r\n  // **FINDS START TIME ***\r\n\r\n  /*** FIND DARK HOURS****/\r\n  let nightHours = []; //these are the night hours of the closest night.\r\n\r\n  let optimumTime = \"\"; // optimum time needs to be defined as early as here because of the base case\r\n  let timeOfAccess = Number(w.location.localtime.slice(11, -3)); //Time the person accessed the website\r\n\r\n  //This whole part is different from the other responses, as we deal with 2 days\r\n  if (timeOfAccess > sunriseHourDay1 && timeOfAccess < sunsetHourDay1) {\r\n    let day1ValidHours = unfilteredHoursDay1.slice(\r\n      sunsetHourDay1,\r\n      unfilteredHoursDay1.length\r\n    );\r\n    let day2ValidHours = unfilteredHoursDay2.slice(0, sunriseHourDay2);\r\n    nightHours.push(day1ValidHours, day2ValidHours);\r\n  } else if (timeOfAccess > sunsetHourDay1) {\r\n    let day1ValidHours = unfilteredHoursDay1.slice(\r\n      timeOfAccess,\r\n      unfilteredHoursDay1.length\r\n    );\r\n    let day2ValidHours = unfilteredHoursDay2.slice(0, sunriseHourDay2);\r\n    nightHours.push(day1ValidHours, day2ValidHours);\r\n  } else if (timeOfAccess < sunriseHourDay1) {\r\n    let day1ValidHours = unfilteredHoursDay1.slice(\r\n      timeOfAccess,\r\n      sunriseHourDay1\r\n    );\r\n    nightHours.push(day1ValidHours);\r\n  }\r\n\r\n  /***FINDS DRY HOURS***/\r\n  //pushes the sunny hours to either a dryHours or rainyDayHours array\r\n  let dryHours = []; //these are dry hours in a day\r\n  let rainyDayHours = []; //hours to use on a rainy day (all)\r\n  for (let i = 0; i < nightHours.length; i++) {\r\n    for (let j = 0; j < nightHours[i].length; j++) {\r\n      for (let k = 0; k < nightHours[i][j].length; k++)\r\n        if (nightHours[i][j][k].will_it_rain === 0) {\r\n          dryHours.push(nightHours[i][j]);\r\n        }\r\n    }\r\n  }\r\n  // *** IF NO DRY HOURS, ALL HOURS ARE \"ELIGIBLE\" HOURS***//\r\n  if (dryHours.length === 0) rainyDayHours = nightHours;\r\n\r\n  //**** SORTS HOURS INTO TEMERATURE TYPE *** //\r\n  let comfortableTemp = [];\r\n  let coldTemp = [];\r\n  let rainyCold = [];\r\n  let rainyHot = [];\r\n  let rainyComfortable = [];\r\n  let veryHot = [];\r\n\r\n  if (rainyDayHours.length === 0) {\r\n    //if not going to rain all night\r\n    for (let i = 0; i < dryHours.length; i++) {\r\n      // loop through dry hours array to find right hour\r\n      for (let j = 0; j < dryHours[i].length; j++) {\r\n        if ((dryHours[i][j].temp_c > 10) & (dryHours[i][j].temp_c <= 20)) {\r\n          comfortableTemp.push(dryHours[i]); // if temp between 10 and 20, push to comfortable array\r\n        } else if (dryHours[i][j].temp_c < 10) {\r\n          coldTemp.push(dryHours[i]); // if temp less than 10, push to coldtemp array\r\n        } else if (dryHours[i][j].temp_c > 20) {\r\n          veryHot.push(dryHours[i]); // if temp more than 20, push to veryhot array\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    //if whole night is rainy\r\n    for (let i = 0; i < rainyDayHours.length; i++) {\r\n      for (let j = 0; j < rainyDayHours[i].length; j++) {\r\n        if (\r\n          (rainyDayHours[i][j].temp_c > 10) &\r\n          (rainyDayHours[i][j].temp_c <= 20)\r\n        ) {\r\n          rainyComfortable.push(rainyDayHours[i]); //push temps between 10 and 20 to rainycomfortable\r\n        } else if (rainyDayHours[i][j].temp_c <= 10) {\r\n          rainyCold.push(rainyDayHours[i]); // push temps <= 10 to rainycold\r\n        } else if (rainyDayHours[i][j].temp_c > 20) {\r\n          rainyHot.push(rainyDayHours[i]); // push temps > 20 to rainyhot\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /***SORT TEMP ARRAYS BY A CONDITION ***/\r\n\r\n  let sortTemps = (oldArray, value, direction) => {\r\n    let newArray = oldArray.sort(function(a, b) {\r\n      switch (value) {\r\n        case \"wind_mph\":\r\n          if (direction === \"low-high\") {\r\n            return a[1].wind_mph - b[1].wind_mph;\r\n          } else return b[1].wind_mph - a[1].wind_mph;\r\n        case \"temp_c\":\r\n          if (direction === \"low-high\") {\r\n            return a[1].temp_c - b[1].temp_c;\r\n          } else return b[1].temp_c - a[1].temp_c;\r\n        case \"humidity\":\r\n          if (direction === \"low-high\") {\r\n            return a[1].humidity - b[1].humidity;\r\n          } else return b[1].humidity - a[1].humidity;\r\n        case \"totalprecip_mm\":\r\n          if (direction === \"low-high\") {\r\n            return a[1].totalprecip_mm - b[1].totalprecip_mm;\r\n          } else return b[1].totalprecip_mm - a[1].totalprecip_mm;\r\n      }\r\n    });\r\n    return newArray;\r\n  };\r\n  // uses the above function to sort all the temperatures in each array.\r\n  let sortedComfortableTemp = sortTemps(\r\n    comfortableTemp,\r\n    \"humidity\",\r\n    \"low-high\"\r\n  );\r\n  let sortedVeryHot = sortTemps(veryHot, \"wind_mph\", \"high-low\");\r\n  let sortedCold = sortTemps(coldTemp, \"wind_mph\", \"low-high\");\r\n  let sortedRainyCold = sortTemps(rainyCold, \"totalprecip_mm\", \"low-high\");\r\n  let sortedRainyHot = sortTemps(rainyHot, \"temp_c\", \"low-high\");\r\n  let sortedRainyComfortable = sortTemps(\r\n    rainyComfortable,\r\n    \"totalprecip_mm\",\r\n    \"low-high\"\r\n  );\r\n\r\n  // ** FINDS OPTIMUM TIME ** //\r\n  let weatherConditionsAtTime = \"\"; // weather conditions at time of walk\r\n  let icon = \"\";\r\n  //temp\r\n  let temperatureAtTime = \"\";\r\n  //functino to find the optimum time\r\n  let findTime = arrayToCheck => {\r\n    if (Number(arrayToCheck[0][0]) > 12) {\r\n      optimumTime = Number(arrayToCheck[0][0] - 12) + \".00 p.m.\";\r\n    } else if (Number(arrayToCheck[0][0]) === 12) {\r\n      optimumTime = Number(arrayToCheck[0][0]) + \".00 p.m.\";\r\n    } else {\r\n      optimumTime = Number(arrayToCheck[0][0]) + \".00 a.m.\";\r\n    }\r\n    weatherConditionsAtTime =\r\n      \"Weather at this time:  \" +\r\n      arrayToCheck[0][1].condition.text.toLowerCase(); //sets weather conditions\r\n    icon = arrayToCheck[0][1].condition.icon; //sets icon\r\n\r\n    temperatureAtTime =\r\n      \"Estimated temperature:  \" + arrayToCheck[0][1].temp_c + \"ºC\"; //sets weather conditions\r\n  };\r\n\r\n  //uses above function to find the optimum time by going through arrays in the following order:\r\n  if (sortedComfortableTemp.length > 0) {\r\n    findTime(sortedComfortableTemp);\r\n  } else if (sortedVeryHot.length > 0) {\r\n    findTime(sortedVeryHot);\r\n  } else if (sortedCold.length > 0) {\r\n    findTime(sortedCold);\r\n  } else if (sortedRainyComfortable.length > 0) {\r\n    findTime(sortedRainyComfortable);\r\n  } else if (sortedRainyHot.length > 0) {\r\n    findTime(sortedRainyHot);\r\n  } else if (sortedRainyCold.length > 0) {\r\n    findTime(sortedRainyCold);\r\n  } else if (timeOfAccess < sunriseHourDay1) {\r\n    optimumTime = \"Now\"; // if none of the arrays have values, and time of access is before sunset, then\r\n    //the time is in the last hour before sunset. So people will need to get out now.\r\n  }\r\n  //I might not need this for nightmode\r\n  //   else if (timeOfAccess === sunriseHour) {\r\n  //     optimumTime = \"Tomorrow\"; // best time is tomorrow if access time is after sunset\r\n  //   }\r\n\r\n  // *** DEFINES A LATE MESSAGE *** //\r\n  let lateMessage = \"\";\r\n  //if (optimumTime === \"Tomorrow\") lateMessage += \"It's already dark.\";\r\n  if (optimumTime === \"Now\")\r\n    lateMessage += \"Get out quickly. There'll be daylight within the hour.\";\r\n  if (optimumTime !== \"Now\") {\r\n    return (\r\n      // This is the final response if a time is shown\r\n      <div className=\"ResponseNight\">\r\n        <p>\r\n          <h1 id=\"location\">\r\n            {w.location.name}, {w.location.country}\r\n          </h1>\r\n          The best time for your night walk is<br></br>\r\n          <span id=\"time\">{optimumTime} </span>\r\n        </p>\r\n        <p>\r\n          <img id=\"icon\" src={icon} /> <br></br>\r\n          {weatherConditionsAtTime}\r\n          <br></br>\r\n          {temperatureAtTime}\r\n        </p>\r\n      </div>\r\n    );\r\n  } else {\r\n    return (\r\n      // This is the final response if \"tomorrow\" is shown\r\n      <div className=\"ResponseNight\">\r\n        <p>\r\n          <h1 id=\"location\">\r\n            {w.location.name}, {w.location.country}{\" \"}\r\n          </h1>{\" \"}\r\n          The best time for your night walk is<br></br>\r\n          <span id=\"time\">{optimumTime} </span>\r\n          <br></br> {lateMessage}\r\n        </p>\r\n        <p></p>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ResponseNight;\r\n","C:\\Users\\Usuario\\OneDrive\\Desktop\\CodeOp\\WhenShouldIWalk\\client\\src\\Components\\ChangeBackground.js",[],{"ruleId":"67","replacedBy":"68"},{"ruleId":"69","replacedBy":"70"},{"ruleId":"71","severity":1,"message":"72","line":19,"column":8,"nodeType":"73","messageId":"74","endLine":19,"endColumn":13},{"ruleId":"71","severity":1,"message":"75","line":22,"column":7,"nodeType":"73","messageId":"74","endLine":22,"endColumn":14},{"ruleId":"76","severity":1,"message":"77","line":159,"column":9,"nodeType":"78","endLine":167,"endColumn":10},{"ruleId":"79","severity":1,"message":"80","line":13,"column":5,"nodeType":"81","messageId":"82","endLine":23,"endColumn":6},{"ruleId":"83","severity":1,"message":"84","line":89,"column":34,"nodeType":"85","messageId":"86","endLine":89,"endColumn":42},{"ruleId":"79","severity":1,"message":"80","line":90,"column":7,"nodeType":"81","messageId":"82","endLine":107,"endColumn":8},{"ruleId":"87","severity":1,"message":"88","line":186,"column":11,"nodeType":"78","endLine":186,"endColumn":39},{"ruleId":"83","severity":1,"message":"84","line":88,"column":34,"nodeType":"85","messageId":"86","endLine":88,"endColumn":42},{"ruleId":"79","severity":1,"message":"80","line":89,"column":7,"nodeType":"81","messageId":"82","endLine":106,"endColumn":8},{"ruleId":"87","severity":1,"message":"88","line":187,"column":11,"nodeType":"78","endLine":187,"endColumn":39},{"ruleId":"71","severity":1,"message":"89","line":19,"column":7,"nodeType":"73","messageId":"74","endLine":19,"endColumn":21},{"ruleId":"83","severity":1,"message":"84","line":114,"column":34,"nodeType":"85","messageId":"86","endLine":114,"endColumn":42},{"ruleId":"79","severity":1,"message":"80","line":115,"column":7,"nodeType":"81","messageId":"82","endLine":132,"endColumn":8},{"ruleId":"87","severity":1,"message":"88","line":214,"column":11,"nodeType":"78","endLine":214,"endColumn":39},"no-native-reassign",["90"],"no-negated-in-lhs",["91"],"no-unused-vars","'error' is assigned a value but never used.","Identifier","unusedVar","'history' is assigned a value but never used.","jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","array-callback-return","Array.prototype.sort() expects a value to be returned at the end of function.","FunctionExpression","expectedAtEnd","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","'sunsetHourDay2' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]